<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>functional JS - #3</title>
  <style>
  </style>
</head>
<body>
  
  <script src="./fx.js"></script> 
  <script>
    //객체를 이터러블 프로그래밍 다루기 
    //1. values
    const obj = {
      a:1,
      b:2,
      c:3,
      d:4
    }

    console.log(Object.values(obj))//즉시평가함 [1,2,3,4]
    //Object.values를 지연 평가하는 L.values를 만들자

    L.values = function *(obj){
      for(const k in obj){
        yield obj[k];
      }
    }
    console.log(L.values(obj))//L.values {<suspended>}
    console.log(L.values(obj).next().value)//1

      //2. entries를 지연평가하자 
      L.entries = function *(obj){
        for(const k in obj){
          yield [k, obj[k]]; 
        }
      }
      console.log(L.entries(obj).next().value) //["a", 1]

      //3. keys를 지연평가하자 
      L.keys = function *(obj){
        for(const k in obj){
          yield k; 
        }
      }
      console.log(L.keys(obj).next().value) //a

      //4. 어떤 값이든 이터러블 프로그래밍으로 다루기 
      //(제너레이터로 무엇이든 이터레이터로 만들어서 함수형도구를 쓸 수있다.)
      //(제너레이터로 무엇이든 값으로 생각하게 할수있다. )
      
      //이터러블(array...)로 이러터블 프로그래밍 
      //객체를 (제너레이터를 이용해서) 이터레이터로 만들어서 이터러블 프로그래밍
      //어떤 제너레이터이든  이터레이터로 만들어서 이터르블 프로그래밍
      const g1 = function *(stop) {
        let i = -1;
        while (++i < stop) {
          yield 10;
          if (false) yield 20 + 30;
          yield 30;
        }
      };
      console.log([...L.take(3, g1(10))]); //[10, 30, 10]

      //5. Object (a 를 가지고 b로 만드는 것)
      const a = [['a', 1], ['b', 2], ['c', 3]];
      const b = {a: 1, b: 2, c: 3};

      const object = entries => _.go( 
       entries,
       L.map(([k, v]) => ({ [k]: v })),
       _.reduce(Object.assign));

       console.log(object(a)); //{a: 1, b: 2, c: 3}

       const OBJECT = entries => _.reduce((obj, [k, v]) => (obj[k] = v, obj), {}, entries);

       console.log(OBJECT(a));//{a: 1, b: 2, c: 3}
       console.log(OBJECT(L.entries({b: 2, c: 3}))); //{b: 2, c: 3}

       let MAP = new Map();
       MAP.set('a', 10);
       MAP.set('b', 20);
       MAP.set('c', 30);

      console.log(OBJECT(MAP)); //{a: 10, b: 20, c: 30} MAP도 이터러블 프로토콜을 지원함

      //6. mapObject(콜백함수, 객체) //객체의 value에 각각 콜백함수를 실행하여 객체로 반환시킬수있을까?
      //  객체를 우선 entries로 [['키', 값]...]형태로 만든 후      [['a', 1]...]
      //  -> 함수를 적용해서 [['키', 함수적용된값]...] 만든 후     [['a', 11]...] 
      //  -> {키: 함수적용된값} {...}                {a: 11}
      //  -> {키: 값, 키:값, ...}으로 반환 한다      {a:1, b:2, c:3}

      const mapObject = (f, obj) => _.go(
        obj,
        L.entries,
        _.map(([k, v]) => [k, f(v)]),
        OBJECT
      )

      console.log(mapObject(a => a + 10, obj)); //{a: 11, b: 12, c: 13, d: 14}


       
  </script>
</body>
</html>